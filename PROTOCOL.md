# tty-clipboard Wire Protocol

This document describes the Protocol Buffers-based wire protocol between `tty-cb-client` and `tty-cb-server` over a mutually authenticated TLS (OpenSSL) connection.

## Transport Layer
- **Security:** TLS with mutual (client + server) X.509 certificate authentication.
- **Port:** Single TCP port (`SERVER_PORT`, default 5457) for all operations.
- **Reliability:** Stream (TCP); protocol uses length-prefixed envelope framing.
- **Encoding:** Protocol Buffers (proto3) with envelope-based message framing.

## High-Level Flow
1. TCP connect
2. TLS handshake (mutual auth) – connection aborted on certificate failure
3. Client sends protobuf `Envelope` message containing a request (`WriteRequest`, `ReadRequest`, or `SubscribeRequest`)
4. Server processes the request and responds with appropriate `Envelope` messages
5. For write/read operations: single request-response exchange, then connection closes
6. For subscribe operations: server streams `DataFrame` messages until client disconnects or server terminates

## Protocol Buffer Schema

The protocol uses a single `Envelope` message type with a `oneof` body to multiplex different message types over the same connection:

```protobuf
message Envelope {
  oneof body {
    WriteRequest write = 1;
    ReadRequest read = 2;
    SubscribeRequest subscribe = 3;
    WriteResponse write_resp = 4;
    DataFrame data = 5;
    Error error = 6;
  }
}
```

### Message Types

**WriteRequest** - Upload clipboard content
```protobuf
message WriteRequest {
  bytes data = 1;           // Raw clipboard data (any binary content)
  uint64 client_id = 2;     // Client identifier (currently unused, reserved for future features)
  bytes write_uuid = 3;     // 128-bit UUID generated by client to track and deduplicate writes
}
```

**WriteResponse** - Write acknowledgement
```protobuf
message WriteResponse {
  bool ok = 1;              // true = success, false = failure
  string message = 2;       // Error description (e.g., "oversize")
  uint64 message_id = 3;    // Server-assigned unique message ID (0 if rejected)
  bytes write_uuid = 4;     // Echo of the client's write UUID for confirmation
}
```

**ReadRequest** - Fetch current clipboard content
```protobuf
message ReadRequest {}      // Empty message
```

**SubscribeRequest** - Stream clipboard updates
```protobuf
message SubscribeRequest {
  uint64 client_id = 1;     // Client identifier (currently unused, reserved for future features)
}
```

**DataFrame** - Clipboard data response
```protobuf
message DataFrame {
  bytes data = 1;           // Raw clipboard data
  uint64 message_id = 2;    // Unique message ID assigned by server
  bytes write_uuid = 3;     // UUID of the write operation that created this data
}
```

**Error** - Error response (currently unused but reserved)
```protobuf
message Error {
  int32 code = 1;           // Error code
  string message = 2;       // Error description
}
```

## Envelope Framing

Each `Envelope` message is transmitted with a length prefix:

```
+------------------+----------------------+
| Length Prefix    | Envelope (protobuf)  |
| 8 bytes (BE u64) | N bytes              |
+------------------+----------------------+
```

- **Length prefix:** 64-bit big-endian unsigned integer specifying envelope size in bytes
- **Envelope:** Serialized protobuf `Envelope` message

Reading procedure:
1. Read 8 bytes for length prefix
2. Convert from big-endian: `size = be64toh(prefix)`
3. Read exactly `size` bytes
4. Deserialize as protobuf `Envelope`

Writing procedure:
1. Serialize `Envelope` to buffer
2. Convert size to big-endian: `prefix = htobe64(size)`
3. Write 8-byte prefix
4. Write serialized envelope

## Message Exchange Patterns

### WRITE Operation
```
Client → Server:
  Envelope { write: WriteRequest { data, client_id } }

Server → Client:
  Envelope { write_resp: WriteResponse { ok, message, message_id } }
```

**Success:** `ok = true`, `message_id` contains server-assigned ID
**Failure:** `ok = false`, `message` explains reason (e.g., "oversize"), `message_id = 0`

Server increments global `message_id` counter on successful writes.

### READ Operation
```
Client → Server:
  Envelope { read: ReadRequest {} }

Server → Client:
  Envelope { data: DataFrame { data, message_id } }
```

Returns current clipboard content with its associated `message_id`.

### SUBSCRIBE Operation
```
Client → Server:
  Envelope { subscribe: SubscribeRequest { client_id } }

Server → Client (stream):
  Envelope { data: DataFrame { data, message_id } }
  Envelope { data: DataFrame { data, message_id } }
  ... (repeats on each clipboard update)
```

Server tracks subscriber's `last_sent_message_id` to avoid sending duplicate updates.
Stream continues until client disconnects or server receives termination signal (SIGINT).

## Message ID & UUID System

The protocol uses two complementary mechanisms for tracking clipboard updates:

### Message ID (Server-assigned)
- Server maintains a global `message_id` counter (starts at 1)
- Each successful write increments the counter
- Subscribers track their own `last_sent_message_id` locally
- Prevents duplicate sends **within a single connection**

### Write UUID (Client-generated)
- Client generates a unique 128-bit UUID (version 4) for each write operation
- UUID is sent with `WriteRequest` and echoed back in `WriteResponse`
- Server stores the UUID with each clipboard update in `shared_write_uuid`
- All `DataFrame` messages include the `write_uuid` of the operation that created the data
- **Purpose:** Enables deduplication across multiple servers and connections

### Deduplication Strategy
**Single connection (default case):**
- Message ID prevents duplicate sends to the same subscriber
- Server tracks `last_sent_message_id` per subscriber connection
- Prevents sending the same update twice to the same client
- UUID provides origin information (which client/write created this data)

**Multiple ports (multiple servers):**
- When subscribing to multiple servers with `-p port1,port2,...`
- Each server independently maintains its clipboard and `message_id` counter
- Client receives updates from whichever port has data first
- No UUID-based deduplication on client side (server-side message_id is sufficient)
- Each subscriber connection to a server tracks its own `last_sent_message_id`

**Benefits:**
- Message ID is the authoritative deduplication mechanism
- Works per-connection, preventing double-delivery to same client
- Server-side tracking is simpler and more reliable than client-side
- UUID identifies the write origin for monitoring/debugging

## Oversize Policy

Configured via `--max-size <limit>` and `--oversize-policy <reject|drop>`:

- **max-size = 0:** Unlimited clipboard size
- **reject policy:** Server rejects write, sends `WriteResponse { ok: false, message: "oversize", message_id: 0 }`
- **drop policy:** Server accepts but discards write, sends `WriteResponse { ok: true, message_id: 0 }` (clipboard unchanged)

When `max_buffer_size` is exceeded:
1. Server checks policy
2. For reject: immediately responds with failure, doesn't update clipboard
3. For drop: responds with success but doesn't update clipboard
4. Neither increments `message_id` counter

## Concurrency & Synchronization

- **Global buffer:** Single shared clipboard protected by `pthread_mutex`
- **Generation counter:** `gen` increments on successful writes, triggers `pthread_cond_broadcast`
- **Subscribe mode:** Each subscriber thread waits on condition variable for `gen` changes
- **Message ID tracking:** Per-subscriber `last_sent_message_id` prevents duplicate sends within single connection
- **UUID tracking:** Server stores `shared_write_uuid` with each clipboard update; subscribers track last received UUID for deduplication
- **Broadcast wakeup:** All subscribers receive updates using `pthread_cond_broadcast` (not `signal`)
- **Multi-server handling:** When subscribing to multiple ports, client receives updates from any available server

## Client Roles

The client supports multiple operational modes:

| Role              | Description                                      |
|-------------------|--------------------------------------------------|
| `write`           | Write stdin to clipboard, exit                   |
| `read`            | Read clipboard to stdout once, exit              |
| `read_blocked`    | Subscribe to updates, stream to stdout           |

## Error Handling

**Write failures:**
- Oversize with reject policy: `ok = false`, `message = "oversize"`
- Memory allocation failure: Server breaks connection
- Protocol errors: Connection closed without response

**Read/Subscribe failures:**
- Malformed envelope: Connection closed
- SSL errors: Connection terminated
- Server shutdown: Clean `DataFrame` stream termination

Clients should detect:
- Unexpected EOF (incomplete envelope)
- Protobuf deserialization failures
- `ok = false` in `WriteResponse`

## Empty Payloads

- `data` field can be empty (0 bytes) representing empty clipboard
- Empty clipboard is valid state and transmits normally
- Write of empty data: accepted, `ok = true`, clipboard cleared

## Client Implementation Notes

**Sending messages:**
```c
1. Initialize Envelope structure
2. Pack envelope: ttycb__envelope__pack()
3. Convert size to big-endian
4. SSL_write() length prefix (8 bytes)
5. SSL_write() packed envelope
```

**Receiving messages:**
```c
1. SSL_read() 8 bytes for length
2. Convert from big-endian: be64toh()
3. Allocate buffer
4. SSL_read() exact envelope size
5. Unpack: ttycb__envelope__unpack()
6. Process based on body case
7. Free: ttycb__envelope__free_unpacked()
```

## Security Considerations

- **Mutual TLS:** Both client and server certificates required, verified on connection
- **Memory safety:** Protobuf library handles bounds checking during deserialization
- **DoS mitigation:** `max_buffer_size` limits memory consumption per write
- **No command injection:** Binary protocol eliminates string parsing vulnerabilities
- **Client ID:** Currently unused; reserved for future authentication/authorization features

## Advantages Over Classic Protocol

1. **Binary safety:** No null-byte truncation issues
2. **Structured data:** Type-safe message encoding
3. **Extensibility:** Easy to add new fields without breaking compatibility
4. **Message IDs:** Built-in update tracking and loop prevention
5. **Clear semantics:** Request/response pattern with explicit success/failure
6. **Future-proof:** Reserved fields for authentication, compression, metadata

## Extensibility

Future enhancements can leverage protobuf's backward compatibility:

**Potential additions:**
- Compression flag in `WriteRequest`
- Clipboard metadata (MIME type, timestamp, source application)
- Client authentication tokens in `client_id` or new field
- Multi-clipboard support (clipboard name/ID field)
- Transactional semantics (message acknowledgment)
- Partial reads (offset + length in `ReadRequest`)

**Compatibility strategy:**
- Unknown fields are ignored by older clients (proto3 behavior)
- New message types can be added to `Envelope.oneof`
- Clients check `body` case before processing
- Version negotiation could use reserved `Error` message on mismatch

## Example Message Flow

**Write 5 bytes "hello":**
```
Client → Server:
  [8-byte BE length: 0x000000000000000B]
  Envelope { write: WriteRequest { data: "hello", client_id: 0x1234567890ABCDEF } }

Server → Client:
  [8-byte BE length: 0x0000000000000008]
  Envelope { write_resp: WriteResponse { ok: true, message: "", message_id: 42 } }
```

**Read clipboard:**
```
Client → Server:
  [8-byte BE length: 0x0000000000000002]
  Envelope { read: ReadRequest {} }

Server → Client:
  [8-byte BE length: 0x000000000000000A]
  Envelope { data: DataFrame { data: "hello", message_id: 42 } }
```

**Subscribe to updates:**
```
Client → Server:
  [8-byte BE length: 0x0000000000000008]
  Envelope { subscribe: SubscribeRequest { client_id: 0x1234567890ABCDEF } }

Server → Client (stream):
  [8-byte BE length: 0x000000000000000A]
  Envelope { data: DataFrame { data: "hello", message_id: 42 } }
  
  ... (waits for clipboard update) ...
  
  [8-byte BE length: 0x000000000000000B]
  Envelope { data: DataFrame { data: "world", message_id: 43 } }
  
  ... (continues until disconnect) ...
```

## Versioning

Protocol changes should:
1. Increment software version (`VERSION` macro)
2. Update this document
3. Add new fields as optional (proto3 default behavior)
4. Consider protocol version field if breaking changes needed

Current implementation: Protobuf-only (classic TLV protocol removed as of v1.x)

---
**Schema:** proto/clipboard.proto  
**Generated:** 2025-12-02  
**Protocol:** Protobuf v3 with envelope framing
